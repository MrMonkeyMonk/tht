#!/bin/bash

if [ -n "$DEBUG" ]; then set -x; set -e; fi

IMAGE=${IMAGE:-ethack/tht}
# switch to ghcr.io if dockerhub fails due to rate limits
#IMAGE=ghcr.io/ethack/tht
PERSISTENT=/usr/local/share/zsh/

# if the current user doesn't have docker permissions run with sudo
DOCKER=docker
if [ ! -w "/var/run/docker.sock" ]; then	
    DOCKER="sudo --preserve-env docker"	
fi

docker_cmd=(
    "container" "run"
    "--rm"
    "--hostname" "$(hostname)"
    "--init"
    "--pid" "host"
    "--mount" "source=/etc/localtime,destination=/etc/localtime,type=bind"
    "--mount" "source=/var/run/docker.sock,destination=/var/run/docker.sock,type=bind"
    "--mount" "source=/,destination=/host,type=bind"
    # resolve the current path in case it's in a symlinked directory 
    "--workdir" "/host/$(pwd | xargs realpath)"
)
CMD=()

while [ $# -gt 0 ]; do
    case $1 in
    update|pull|--pull)
        echo "Downloading latest THT image..."
        $DOCKER pull $IMAGE
        SUDO=
        if [ ! -w "$0" ]; then
            SUDO="sudo"
        fi
        echo "Self-updating THT script..."
        $SUDO curl -s https://raw.githubusercontent.com/ethack/tht/main/tht > "$0"
        # run the updated script with the same parameters minus the one that triggered the update
        shift
        exec "$0" "$@"
    ;;
    version)
        CMD=(zsh -c "cat /etc/tht-release")
        break
    ;;
    run)
        # TODO: give a tht prefix to mktemp
        # create temporary file to store commands/script
        SCRIPT=$(mktemp -u)
        trap "rm -f $SCRIPT" EXIT

        # get command from an argument, if specified
        if [ -n "$2" ]; then
            echo "$2" > $SCRIPT
            shift
        # otherwise read commands from stdin
        else
            cat > $SCRIPT
        fi

        # TODO: allow passing in a script file to run directly instead of piping on stdin
        # TODO: --flock and --nice options; flock lock must be stored in /host volume or else a docker volume (e.g. zsh cache)
        # flock lock must be deterministic; maybe per identical input (md5 of script); or specified manually

        # mount the temp file in the container and execute it
        docker_cmd+=("--mount" "source=$SCRIPT,destination=/run.sh,type=bind")
        if head -n 1 $SCRIPT | grep -q '^#!'; then
            # script has a shebang; execute it directly with the defined interpreter
            # TODO: this will fail if tmpfs is mounted as noexec
            # could strip off #! and run interpreter directly
            # or copy script into container instead, but that would mean creating the container first
            chmod +x $SCRIPT
            CMD+=(/run.sh)
        else
            # run script using zsh
            CMD+=(zsh /run.sh)
        fi
    ;;
    dev|--dev)
        # change to directory this script is in, following any symlinks
        pushd "$(dirname "$(readlink -f "${BASH_SOURCE[0]}")")" >/dev/null
        # loop through dynamically to prevent having to update on every new addition
        while IFS=  read -r -d $'\0' PROG; do
            # mount bin scripts for development
            docker_cmd+=("--mount" "source=$(pwd)/${PROG},destination=/usr/local/bin/${PROG#"bin"},type=bind")
        done < <(find bin -type f -print0 2>/dev/null)
        while IFS=  read -r -d $'\0' CONF; do
            # mount zsh configs for development
            docker_cmd+=("--mount" "source=$(pwd)/${CONF},destination=/root/${CONF#"zsh"},type=bind")
        done < <(find zsh -type f -print0 2>/dev/null)
        popd >/dev/null
    ;;
    esac
    shift
done

# create and use a persistent volume
$DOCKER volume create tht_zsh-cache >/dev/null && \
    docker_cmd+=("--mount" "source=tht_zsh-cache,destination=${PERSISTENT},type=volume")

# connect a tty when not running a command/script
if [ -z "$CMD" ]; then
    docker_cmd+=("--interactive" "--tty")
fi

$DOCKER "${docker_cmd[@]}" "$IMAGE" "${CMD[@]}"


# TODO: create a service option for long running processes (e.g. vector), that have healthchecks and restart policy