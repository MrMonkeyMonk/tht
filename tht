#!/bin/bash

if [ -n "$DEBUG" ]; then set -x; set -e; fi

IMAGE=${IMAGE:-ethack/tht}
# switch to ghcr.io if dockerhub fails due to rate limits
#IMAGE=ghcr.io/ethack/tht
PERSISTENT=/usr/local/share/zsh/

# if the current user doesn't have docker permissions run with sudo
DOCKER=docker
if [ ! -w "/var/run/docker.sock" ]; then	
    DOCKER="sudo --preserve-env docker"	
fi

usage() {
    cat <<EOF
Usage: tht [update|pull|version|dev] [run <arg>] [-- [<args>]]

Run tht without arguments for normal use.

    update   Download the latest THT image and update the script before running.
    pull     Download the latest THT image before running (don't update this script).
    version  Print the THT version.
    dev      Start THT in dev mode. For development purposes only.

    run      Run either the script from stdin or following argument inside THT.
    --       Any arguments after the -- are run inside THT in _interactive_ mode.

EOF
}

docker_cmd=(
    container run
    --rm
    --hostname "$(hostname)"
    --init
    --pid host
    --env "TERM=${TERM}"
    --mount source=/etc/localtime,destination=/etc/localtime,type=bind
    --mount source=/,destination=/host,type=bind
    # resolve the current path in case it's in a symlinked directory 
    --workdir "/host/$(realpath "${PWD}")"
    --add-host host.docker.internal:host-gateway
)
CMD=()
BACKGROUNDJOB=false
while [ $# -gt 0 ]; do
    case $1 in
    help|-h|--help)
        usage
        exit 0
    ;;
    update)
        echo "Downloading latest THT image..."
        $DOCKER pull $IMAGE
        SUDO=
        if [ ! -w "$0" ]; then
            SUDO="sudo"
        fi
        echo "Self-updating THT script..."
        $SUDO curl -s https://raw.githubusercontent.com/ethack/tht/main/tht -o "$0"
        # run the updated script with the same parameters minus the one that triggered the update
        shift
        exec "$0" "$@"
    ;;
    pull)
        echo "Downloading latest THT image..."
        $DOCKER pull $IMAGE
        SUDO=
        if [ ! -w "$0" ]; then
            SUDO="sudo"
        fi
        # Don't update the THT script
        # echo "Self-updating THT script..."
        # $SUDO curl -s https://raw.githubusercontent.com/ethack/tht/main/tht -o "$0"
        # run the updated script with the same parameters minus the one that triggered the update
        shift
        exec "$0" "$@"
    ;;
    version)
        CMD=(zsh -c "cat /etc/tht-release")
        break
    ;;
    run)
        BACKGROUNDJOB=true
        # TODO: give a tht prefix to mktemp
        # create temporary file to store commands/script
        SCRIPT=$(mktemp -u)
        trap "rm -f $SCRIPT" EXIT

        # get command from an argument, if specified
        if [ -n "$2" ]; then
            echo "$2" > $SCRIPT
            shift
        # otherwise read commands from stdin
        else
            cat > $SCRIPT
        fi

        # TODO: allow passing in a script file to run directly instead of piping on stdin
        # TODO: --flock and --nice options; flock lock must be stored in /host volume or else a docker volume (e.g. zsh cache)
        # flock lock must be deterministic; maybe per identical input (md5 of script); or specified manually

        # mount the temp file in the container and execute it
        docker_cmd+=("--mount" "source=$SCRIPT,destination=/run.sh,type=bind")
        if head -n 1 $SCRIPT | grep -q '^#!'; then
            # script has a shebang; execute it directly with the defined interpreter
            # TODO: this will fail if tmpfs is mounted as noexec
            # could strip off #! and run interpreter directly
            # or copy script into container instead, but that would mean creating the container first
            chmod +x $SCRIPT
            CMD+=(/run.sh)
        else
            # run script using zsh
            CMD+=(zsh /run.sh)
        fi
    ;;
    dev|--dev)
        # change to directory this script is in, following any symlinks
        pushd $(dirname $(readlink -f "${BASH_SOURCE[0]}")) >/dev/null
        # loop through dynamically to prevent having to update on every new addition
        while IFS=  read -r -d $'\0' PROG; do
            # mount bin scripts for development
            docker_cmd+=("--mount" "source=${PWD}/${PROG},destination=/usr/local/bin/${PROG#"bin"},type=bind")
        done < <(find bin -type f -print0 2>/dev/null)
        while IFS=  read -r -d $'\0' CONF; do
            # mount zsh configs for development
            docker_cmd+=("--mount" "source=${PWD}/${CONF},destination=/root/${CONF#"zsh"},type=bind")
        done < <(find zsh -type f -print0 2>/dev/null)
        docker_cmd+=("--mount" "source=${PWD}/test,destination=/usr/local/test,type=bind")
        popd >/dev/null
    ;;
    --)
        # anything after -- is treated as a command to run in interactive mode
        shift
        CMD+=(zsh -c "$*")
        break
    ;; 
    esac
    shift
done

# create and use a persistent volume
$DOCKER volume create tht_zsh-cache >/dev/null && \
    docker_cmd+=("--mount" "source=tht_zsh-cache,destination=${PERSISTENT},type=volume")

# connect a tty when not running a background command/script
if ! $BACKGROUNDJOB; then
    docker_cmd+=("--interactive" "--tty")
fi

$DOCKER "${docker_cmd[@]}" "$IMAGE" "${CMD[@]}"


# TODO: create a service option for long running processes (e.g. vector), that have healthchecks and restart policy