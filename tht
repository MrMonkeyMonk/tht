#!/bin/bash

if [ -n "$DEBUG" ]; then set -x; set -e; fi

IMAGE=${IMAGE:-ethack/tht}
# switch to ghcr.io if dockerhub fails due to rate limits
#IMAGE=ghcr.io/ethack/tht
PERSISTENT=/usr/local/share/zsh/

# if the current user doesn't have docker permissions run with sudo
DOCKER=docker
if [ ! -w "/var/run/docker.sock" ]; then	
    DOCKER="sudo --preserve-env docker"	
fi

usage() {
    cat <<EOF
Usage: tht [command] [flags] [-- [<args>]]

Run tht without arguments for normal use.

Commands:
    update   Download the latest THT image and updates this script
    version  Print the THT version
    run      Run a script from stdin inside THT

Flags:
    --experimental  Enable experimental features
    --dev           Start THT in development mode

Arguments:
    --       Any arguments after the -- are run inside THT in _interactive_ mode.

EOF
}

docker_cmd=(
    container run
    --rm
    --hostname "$(hostname)"
    --init
    --pid host
    --env "TERM=${TERM}"
    --mount source=/etc/localtime,destination=/etc/localtime,type=bind
    --mount source=/,destination=/host,type=bind
    # resolve the current path in case it's in a symlinked directory 
    --workdir "/host/$(realpath "${PWD}")"
)
CMD=()
BACKGROUNDJOB=false
while [ $# -gt 0 ]; do
    case $1 in
    help|-h|--help)
        usage
        exit 0
    ;;
    update|pull)
        # exit if any of the update commands fail
        set -e

        echo "Downloading latest THT image..."
        $DOCKER pull $IMAGE
        SUDO=
        if [ ! -w "$0" ]; then
            SUDO="sudo"
        fi

        # hidden feature to disable clobbering this script for development
        if [[ $1 != pull ]]; then
            echo "Self-updating THT script..."
            $SUDO curl -s https://raw.githubusercontent.com/ethack/tht/main/tht -o "$0"
        fi

        # remove all dangling tht images
        if [[ $($DOCKER image ls --no-trunc --quiet $IMAGE --filter "dangling=true" | wc -l) -gt 0 ]]; then
            echo "Removing old THT images..."
            $DOCKER image rm --force $($DOCKER image ls --no-trunc --quiet $IMAGE --filter "dangling=true")
        fi       
        exit 0
    ;;
    version)
        CMD=(zsh -c "cat /etc/tht-release")
        break
    ;;
    run)
        BACKGROUNDJOB=true
        # TODO: give a tht prefix to mktemp
        # create temporary file to store commands/script
        SCRIPT=$(mktemp -u)
        trap "rm -f '$SCRIPT'" EXIT
        cat > $SCRIPT

        # mount the temp file in the container and execute it
        docker_cmd+=(--mount "source=${SCRIPT},destination=/run.sh,type=bind")
        if head -n 1 $SCRIPT | grep -q '^#!'; then
            # script has a sh-bang; execute it directly with the defined interpreter
            # NOTE: this will fail if tmpfs is mounted as noexec
            chmod +x $SCRIPT
            CMD+=(/run.sh)
        else
            # run script using zsh
            CMD+=(zsh /run.sh)
        fi
    ;;
    --dev)
        # change to directory this script is in, following any symlinks
        pushd $(dirname $(readlink -f "${BASH_SOURCE[0]}")) >/dev/null
        # loop through dynamically to prevent having to update on every new addition
        while IFS=  read -r -d $'\0' PROG; do
            # mount bin scripts for development
            docker_cmd+=(--mount "source=${PWD}/${PROG},destination=/usr/local/bin/${PROG#"bin"},type=bind")
        done < <(find bin -type f -print0 2>/dev/null)
        while IFS=  read -r -d $'\0' CONF; do
            # mount zsh configs for development
            docker_cmd+=(--mount "source=${PWD}/${CONF},destination=/root/${CONF#"zsh"},type=bind")
        done < <(find zsh -type f -print0 2>/dev/null)
        while IFS=  read -r -d $'\0' CHEAT; do
            # mount navi cheats development
            docker_cmd+=(--mount "source=${PWD}/${CHEAT},destination=/root/.local/share/navi/cheats/${CHEAT#"cheatsheets"},type=bind")
        done < <(find cheatsheets -type f -print0 2>/dev/null)
        docker_cmd+=(--mount "source=${PWD}/test,destination=/usr/local/test,type=bind")
        popd >/dev/null
        # also enable experimental mode
        docker_cmd+=(--env "EXPERIMENTAL=true")
    ;;
    --experimental)
        docker_cmd+=(--env "EXPERIMENTAL=true")
    ;;
    --)
        shift
        if $BACKGROUNDJOB; then
            # anything after -- is passed as an argument to the run script
            CMD+=("$@")
        else
            # anything after -- is treated as a command to run in interactive mode
            CMD+=(zsh -c "$*")
        fi
        break
    ;; 
    esac
    shift
done

# mount docker inside if we can find it, and it's not the snap version
if [[ -e $(command -v docker) ]] \
   && ! snap list docker >/dev/null 2>&1 \
   && [[ -e /var/run/docker.sock ]]; then
    # mount the docker binary inside as well so we don't have to bundle it in THT
    docker_cmd+=(
        --mount "source=$(command -v docker),destination=/usr/local/bin/docker,type=bind"
        --mount "source=/var/run/docker.sock,destination=/var/run/docker.sock,type=bind"
    )
fi

# create and use a persistent volume
$DOCKER volume create tht_zsh-cache >/dev/null && \
    docker_cmd+=(--mount "source=tht_zsh-cache,destination=${PERSISTENT},type=volume")

# connect a tty when not running a background command/script
if ! $BACKGROUNDJOB; then
    docker_cmd+=(--interactive --tty)
fi

$DOCKER "${docker_cmd[@]}" "$IMAGE" "${CMD[@]}"


# TODO: create a service option for long running processes (e.g. vector), that have healthchecks and restart policy
