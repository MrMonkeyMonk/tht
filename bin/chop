#!/bin/bash

if [ -n "$DEBUG" ]; then set -x; set -e; fi

if [[ $# -eq 0 ]]; then
    2>&1 echo "Usage: $0 [-h|--headers] <fields>"
    2>&1 echo "  -h|--headers  request headers be maintained in the output (default omitted where possible)"
    exit 2
fi

headerFlag=false
if [[ $1 =~ -h|--headers ]]; then
    shift
    headerFlag=true
fi

# true if the arguments passed in all look like indexes (not field names)
indexArgs=false
if echo $* | grep -q '^[0-9, -]*$'; then
    indexArgs=true
fi

commaArgs="$(echo $* | tr ' ' ',')"
spaceArgs="$(echo $* | tr ',' ' ')"

# read the first line in order to detect the type of log
read -r LINE

match() {
    [[ $LINE =~ $1 ]]
}

stdin() {
    (echo "$LINE"; cat)
}

# default to including headers / first row in output
zeek_cut="zeek-cut -c"  # include full zeek headers
conditionalHeader="cat" # xsv includes headers by default

if ! $headerFlag; then
    # assume the input has a header row if the arguments are field names
    if ! $indexArgs; then
        # only in the case where we're reasonably sure there is a header row
        # and the user did not specify the header flag can we omit the headers
        zeek_cut="zeek-cut"            # don't include zeek headers
        conditionalHeader="tail -n +2" # omit first row (header)
    fi
fi

# zeek tsv
if match '^#'; then
    if $indexArgs; then
        # convert to straight TSV
        if $headerFlag; then
            # with headers
            stdin | sed -e '0,/^#fields\t/s///' | grep -v '^#'| xsv select -d '\t' $commaArgs | mlr --c2t cat
        else
            # without headers
            stdin | grep -v '^#' | xsv select --no-headers -d '\t' $commaArgs | mlr --c2t cat
        fi
    else
        stdin | $zeek_cut -u $spaceArgs
    fi
# ndjson
elif match '^\{.*\}$'; then
    # note: output is tsv
    stdin | json-cut $spaceArgs
    # note: json-cut is several orders of magnitude faster than zq v0.29.0
# generic tsv
elif match '.*	.*'; then
    stdin | xsv select -d '\t' $commaArgs | mlr --c2t cat | $conditionalHeader
    # note: xsv is an order of magnitude faster than miller
    # note: xsv only outputs csv, not tsv; piping to miller after is a slight performance hit, depending on number of columns
# generic csv
elif match '.*,.*'; then
    stdin | xsv select $commaArgs | $conditionalHeader
    # note: xsv is an order of magnitude faster than miller
# unknown; fallback to splitting on whitespace
else
    # trim all leading and trailing whitespace and replace consecutive whitespace with a single comma
    # note: converts output to csv
    stdin | sed -E -e 's/^[ \t]*//;s/[ \t]*$//' -e 's/[ \t]+/,/g' | xsv select $commaArgs | $conditionalHeader
fi

# TODO
# idea: 
# - /dev/shm
# - grep for # lines except fields and types
# - sed to convert to tsv
# - send to xsv
# - sed to convert fields and types back

# output is inconsistent
# zeek tsv -> tsv (or zeek tsv)
# json -> tsv
# tsv -> tsv
# csv -> csv
# whitespace -> csv

# allow inverting columns with -v

# allow specifying delimeter with -d