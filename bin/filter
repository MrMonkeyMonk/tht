#!/bin/bash

if [ ! -z "$DEBUG" ]; then set -x; set -e; fi

print_usage() {
    cat << EOF
Filters Zeek logs based on the search terms with output that can be piped to zeek-cut or other tools that can read Zeek logs.

$(basename "$0") [--<logtype>] [OPTIONS] [search_term] [search_term...] [-- [OPTIONS]]

    --<logtype>   is used to search logs of "logtype" (e.g. conn, dns, etc) in the current directory tree (default: conn)

    Specify one or more [search_terms] to filter either STDIN or log files. If you don't specify any search terms, all lines will be printed.
    
    Lines must match all search terms by default.
    -o|--or       at least one search term is required to appear in a line (as opposed to all terms matching)

    Search terms will match on word boundaries by default.
    -s|--starts-with  anchor search term to beginning of field (e.g. 192.168)
    -e|--ends-with    anchor search term to end of field (e.g. google.com)
    -r|--regex        signifies that [search_term(s)] should be treated as regexes

    -n|--dry-run      print out the final search command rather than execute it

    $(basename "$0") will find the first search tool available. Use the following options to force a specific tool.
    --rg          force use of ripgrep
    --ug          force use of ugrep
    --zgrep       force use of zgrep

    Any arguments given after -- will be passed to the underlying search command.

Examples:
    $(basename "$0") 10.0.0.1                            conn entries from the current directory tree that match the IP
    $(basename "$0") 10.0.0.1 1.1.1.1                    conn entries from the current directory tree that match the pair of IPs
    $(basename "$0") --or 8.8.8.8 1.1.1.1                conn entries from the current directory tree that match either of IPs
    cat conn.log | $(basename "$0") 10.0.0.1             conn entries from STDIN that match the IP
    $(basename "$0") --dns 'google.com'                  dns entries from the current directory tree that match the domain or any subdomains
    $(basename "$0") --dns --regex '\tgoogle\.com\t'     dns entries from the current directory tree that match the regex

EOF
}

#TODO require all dependencies before starting:
#zgrep, ug, or rg; sed, printf, xargs, nproc, find, grep, cat, zcat

exists() {
  command -v $1 >/dev/null 2>&1
}

toRegex() {
    term="$1"
    prefix="$2"
    suffix="$3"
    # escape periods and put in word boundaries
    echo "$term" | sed 's/\./\\\\./g' | xargs -n 1 printf "${prefix}%s${suffix}"
}

logType="conn"
search=()
extra_args=()
regex=
condition="and"
dryRun=
grepCmd=
termPrefix='\\b'
termSuffix='\\b'

# process command args
while [[ $# -gt 0 ]]; do
    case $1 in
        -h|--help)
            print_usage
            exit
        ;;
        -s|--starts-with)
            termPrefix='("|\\t)'
        ;;
        -e|--ends-with)
            termSuffix='("|\\t)'
        ;;
        -r|--regex)
            regex="true"
        ;;
        -o|--or)
            condition="or"
        ;;
        -n|--dry-run)
            dryRun="true"
        ;;
        --rg|--ripgrep)
            grepCmd="rg"
        ;;
        --ug|--ugrep)
            grepCmd="ug"
        ;;
        --zgrep|--grep)
            grepCmd="zgrep"
        ;;
        --)
            shift
            # pass through args after "--" to search tool
            extra_args+=("$@")
            break
        ;;
        --*)
            # log type e.g. --conn or --dns
            logType="${1#"--"}"
        ;;
        *)
            # the rest of the arguments are search terms
            search+=("$1")
        ;;
    esac
    shift
done

logFiles=
zipFiles=
files=
# if stdin is not attached, search files of logType in the current directory tree
if [ -t 0 ]; then
    # regex must match entire path, not just filename
    # note: never include conn-summary files and always return a success exit code
    logFiles="$(find . -regextype egrep -iregex ".*/$logType(\b|_).*\.log$" | grep -v conn-summary | sort || true)"
    zipFiles="$(find . -regextype egrep -iregex ".*/$logType(\b|_).*\.log.gz$" | grep -v conn-summary | sort || true)"
    files="$(echo $logFiles $zipFiles | sort)"
    # TODO: test for files/paths with spaces
fi

# pick the best search tool available
if [ ${#search[@]} -eq 0 ]; then
    # use cat if there are no search terms
    grepCmd="cat"
elif [ -n "$grepCmd" ]; then
  : # grep command forced via flag
elif exists rg; then
  grepCmd="rg"
elif exists ug; then
   grepCmd="ug"
elif exists zgrep; then
  grepCmd="zgrep"
fi

if ! exists "$grepCmd"; then
  echo "Could not find a grep program."
  exit 1
fi

filterCmd=""
first="true"
# loop through all search terms
for term in "${search[@]}"; do 
    # if regex flag was not given then escape the search term
    if [ -z "$regex" ]; then
        term="$(toRegex $term $termPrefix $termSuffix)"
    fi
    case $grepCmd in
    rg)
        # special case the first search term
        if [ -n "$first" ]; then
            # disable unicode to avoid taking a speed hit
            # https://github.com/BurntSushi/ripgrep/issues/1860
            # https://github.com/BurntSushi/ripgrep/issues/1760
            filterCmd="rg ${extra_args[@]} --no-filename --no-line-number --no-unicode --search-zip -e '^#' -e '$term' $files"
            first=
        else
            if [ "$condition" = "and" ]; then      # prefer and
                filterCmd="$filterCmd | rg ${extra_args[@]} -e '^#' -e '$term'"
            elif [ "$condition" = "or" ]; then
                filterCmd="$filterCmd -e '$term'"
            fi
        fi
    ;;
    ug)
        # special case the first search term
        if [ -n "$first" ]; then
            filterCmd="ug ${extra_args[@]} --no-filename --decompress --bool '^# OR ($term"
            first=
        else
            if [ "$condition" = "and" ]; then
                filterCmd="$filterCmd AND '$term'"
            elif [ "$condition" = "or" ]; then
                filterCmd="$filterCmd OR '$term'"
            fi
        fi
    ;;
    zgrep)
        # special case the first search term
        if [ -n "$first" ]; then
            # use xargs to parallelize zgrep
            filterCmd="echo $files | xargs -n 1 -P $(nproc) zgrep ${extra_args[@]} -e '^#' -e '$term'"
            first=
        else
            if [ "$condition" = "and" ]; then
                filterCmd="$filterCmd | zgrep ${extra_args[@]} -e '^#' -e '$term'"
            elif [ "$condition" = "or" ]; then
                filterCmd="$filterCmd -e '$term'"
            fi
        fi
    ;;
    esac
done
# special case after search terms when needed
case $grepCmd in
    ug)
        filterCmd="$filterCmd)' $files"
    ;;
    cat)
        # zcat doesn't work on uncompressed files so split it up between cat/zcat
        # not worth it to parallelize the cat command as it's not CPU bound
        filterCmd="cat $logFiles; echo $zipFiles | xargs -n 1 -P $(nproc) zcat"
    ;;
esac

if [ -n "$dryRun" ]; then
    echo $filterCmd
else
    eval $filterCmd
fi


# TODO
# Specify multiple types of logs? e.g.
# filter --http --ssl --dns google.com
# Wouldn't really be useful for zeek-cut. But would be useful for jq and JSON logs.

# make grepcidr an option

# write some unit tests